###### 문제 설명

체스에서 비숍(Bishop)은 아래 그림과 같이 대각선 방향으로 몇 칸이든 한 번에 이동할 수 있습니다. 만약, 한 번에 이동 가능한 칸에 체스 말이 놓여있다면 그 체스 말을 잡을 수 있습니다.

![bishop1.png](https://grepp-programmers.s3.amazonaws.com/files/ybm/07fd25eb65/561e9310-6ee3-4ecf-85bd-dd573bdbb8df.png)

8 x 8 크기의 체스판 위에 여러 개의 비숍(Bishop)이 놓여있습니다. 이때, 비숍(Bishop)들에게  **한 번에**  잡히지 않도록 새로운 말을 놓을 수 있는 빈칸의 개수를 구하려고 합니다.

위 그림에서 원이 그려진 칸은 비숍에게 한 번에 잡히는 칸들이며, 따라서 체스 말을 놓을 수 있는 빈칸 개수는 50개입니다.

8 x 8 체스판에 놓인 비숍의 위치 bishops가 매개변수로 주어질 때, 비숍에게 한 번에 잡히지 않도록 새로운 체스 말을 놓을 수 있는 빈칸 개수를 return 하도록 solution 함수를 완성해주세요.

##### 제한 조건

체스판에 놓인 비숍의 위치 bishops가 solution 함수의 매개변수로 주어집니다.

-   bishops는 비숍의 위치가 문자열 형태로 들어있는 배열입니다.
-   bishops의 길이는 1 이상 64 이하입니다.
-   비숍이 놓인 위치는 알파벳 대문자와 숫자로 표기합니다.
    -   알파벳 대문자는 가로 방향, 숫자는 세로 방향 좌표를 나타냅니다.
    -   예를 들어 위 그림에서 비숍이 있는 칸은  D5라고 표현합니다.
-   한 칸에 여러 비숍이 놓이거나, 잘못된 위치가 주어지는 경우는 없습니다.

##### 입출력 예

bishops

return

[D5]

50

[D5,  E8,  G2]

42

##### 입출력 예 설명

입출력 예 #1  
문제에 나온 예시와 같습니다.

입출력 예 #2

![bishop2.png](https://grepp-programmers.s3.amazonaws.com/files/ybm/b635b0d993/71863e6c-1320-4ce1-8b5b-886c37dcfa5b.png)

그림과 같이 원이 그려진 칸은 비숍에게 한 번에 잡히는 칸들이며, 따라서 체스 말을 놓을 수 있는 빈칸 개수는 42개입니다.

```java
import java.util.*;

public class AAA {
	
	public static boolean isIn(int x, int y){
        return x >= 0 && x < 8 && y >= 0 && y < 8;
    }
    
    public static int solution(String[] bishops) {
        int map[][] = new int[8][8];
        int dx[] = {-1, -1, 1, 1};
        int dy[] = {-1, 1, -1, 1};
        int answer = 0;
        
        // 모든 bishops에 대해
        for(String bishop : bishops){
            // 해당 위치의 좌표값 구하기 0~7
            char[] xy = bishop.toCharArray();
            int x = (int)xy[0] - 65;    // A = 65
            int y = 8 - ((int)xy[1] - 48);
            System.out.println(x+", "+ y);
            
            map[y][x] = 1;
            for(int i=1; i<=8; i++){
                for(int j=0; j<4; j++){
                    int nx = x + dx[j]*i;
                    int ny = y + dy[j]*i;
                    
                    if(!isIn(nx, ny) || map[ny][nx] != 0){
                        continue;
                    } else {
                        map[ny][nx] = 1;
                    }
                }
            }
        }
        
        for(int i=0; i<8; i++) {
        	for(int j=0; j<8; j++) {
        		if(map[i][j] == 0) {
        			answer++;
        		}
        	}
        }
        return answer;
    }
    
	public static void main(String[] args) {
		String[] test = {"D5",  "E8",  "G2", "E3", "A1", "B1"};
		System.out.println(solution(test));
	}
}

```


---

###### 문제 설명

다음 그림과 같이 숫자가 적혀있는 스티커가 한 줄로 붙어있습니다.  
  
![image](https://s3.ap-northeast-2.amazonaws.com/grepp-cloudfront/programmers_imgs/challengeable-imgs/20180131229stk_img_hcdsd8.jpg)  
  
한 줄로 붙어있는 스티커를 가위로 잘라 하나씩 보관하고 싶습니다. 그러나 스티커 한 개를 깨끗하게 자르려면 인접해 있는 스티커들을 가위로 잘라야 합니다. 예를 들어 위 그림에서 80이 적혀있는 스티커를 깨끗하게 자르고 싶으면 먼저 양쪽의 12와 14가 적힌 스티커의 점선 부분을 가위로 잘라낸 후 80이 적힌 스티커의 가장자리를 다듬어야 합니다. 이때 12와 14가 적힌 스티커는 못 쓰게 됩니다.

스티커에 적힌 숫자가 배열 sticker로 주어질 때, 깨끗하게 잘린 스티커에 적힌 숫자의 합이 최대가 되도록 숫자의 합을 반환하는 함수를 완성해 주세요.

##### 제한사항

-   스티커의 길이는 1이상 100,000 이하입니다.
-   스티커에 적힌 숫자는 10,000 이하의 자연수 입니다.

----------

##### 입출력 예
```
sticker							result

[12, 12, 12, 12, 12]			36
[12, 80, 14, 22, 100]			180
```
##### 입출력 예 설명

입출력 예 #1  
스티커에 적힌 숫자가 [12, 12, 12, 12, 12] 인 경우 첫 번째, 세 번째, 다섯 번째의 12가 적힌 스티커 3개를 깨끗하게 자르면 합이 36으로 최대가 됩니다.

입출력 예 #2  
스티커에 적힌 숫자가 [12, 80, 14, 22, 100] 인 경우 80과 100이 적힌 스티커를 깨끗하게 자르면 합이 180으로 최대가 됩니다.


---


###### 문제 설명

n 개의 상품을 k개의 상자에 담아 포장하려고 합니다. 상품을 담을 때는, 상품의 크기보다 크거나 같은 상자에만 담을 수 있으며, 상자 하나에는 한가지 상품만 담아야 합니다. 각 상품의 크기와 상자의 크기는 자연수로 나타냅니다.

예를 들어, 상품 3개의 크기에 대한 정보가 담긴 배열 [5,3,7]이 주어졌을 때, 첫 번째 상품의 크기는 5, 두 번째 상품의 크기는 3, 세 번째 상품의 크기는 7입니다. 마찬가지로, 상자 3개의 크기가 담긴 정보가 담긴 배열 [3,7,6]이 주어졌을 때, 첫 번째 상자의 크기는 3, 두 번째 상자의 크기는 7, 세 번째 상자의 크기는 6입니다.

상품의 크기 goods = [5,3,7] 와 상자의 크기 boxes = [3,7,6] 일 때, 상품을 상자에 담는 방법의 하나는 다음과 같습니다.

-   크기가 5인 첫 번째 상품을 크기가 7인 두 번째 상자에 담습니다.
-   크기가 3인 두 번째 상품을 크기가 3인 첫 번째 상자에 담습니다.
-   크기가 7인 세 번째 상품은 남은 상자 하나의 크기가 6이므로 담을 수 없습니다.

이 상품들을 다음과 같은 방식으로 상자에 담으면, 모든 상품을 상자에 담아 포장할 수 있습니다.

-   크기가 5인 첫 번째 상품을 크기가 6인 세 번째 상자에 담습니다.
-   크기가 3인 두 번째 상품을 크기가 3인 첫 번째 상자에 담습니다.
-   크기가 7인 세 번째 상품을 크기가 7인 두 번째 상자에 담습니다.

이처럼 어떤 방식으로 상품을 상자에 담느냐에 따라 담을 수 있는 상품의 개수가 달라집니다.  **이때 최대한 많은 상품을 상자에 담아 포장하려고 합니다.**

상품들의 크기가 들어있는 배열 goods와 상자의 크기가 들어있는 배열 boxes가 매개변수로 주어질 때, 상자에 넣을 수 있는 상품 개수의 최댓값을 return 하도록 solution 함수를 완성해주세요.

##### 제한사항

-   배열 goods의 길이(상품의 개수 n)는 1 이상 100,000 이하의 자연수입니다.
-   각 상품의 크기는 1 이상 200,000,000 이하의 자연수입니다.
-   배열 boxes의 길이(상자의 개수 k)는 1 이상 100,000 이하의 자연수입니다.
-   각 상자의 크기는 1 이상 200,000,000 이하의 자연수입니다.

----------

##### 입출력 예

goods

boxes

answer

[5,3,7]

[3,7,6]

3

[1,2]

[2,3,1]

2

[3,8,6]

[5,6,4]

2

##### 입출력 예 설명

입출력 예 #1  
문제의 예시와 같습니다.

입출력 예 #2  
가능한 방법의 하나는 다음과 같으며, 최대 2개의 상품을 상자에 담을 수 있습니다.

-   첫 번째 상품은 세 번째 상자에 담습니다.
-   두 번째 상품은 첫 번째 상자에 담습니다.

입출력 예 #3  
가능한 방법의 하나는 다음과 같으며, 최대 2개의 상품을 상자에 담을 수 있습니다.

-   첫 번째 상품은 세 번째 상자에 담습니다.
-   두 번째 상품은 담을 수 없습니다.
-   세 번째 상품은 두 번째 상자에 담습니다.
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTE4NDU1NjE0MiwyOTIyODE0NDAsLTE3Nj
M3MTQ1MzhdfQ==
-->