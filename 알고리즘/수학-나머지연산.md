## 나머지 연산이 출제되는 이유
컴퓨터의 정수는 저장할 수 있는 범위가 한정되어있기 때문에, 답을 M으로 나눈 나머지를 출력하라는 문제가 등장한다. (정답을 ~~~로 나눈 나머지를 출력하라)

java의 int와 long은

int - 2^31 -1
long - 2^63 - 1

까지만 표현가능하므로 이 범위를 넘어가는 숫자 연산을 처리할 수 없다.

## 나머지 연산 (Modular Arithmetic)
```
<덧셈>
(A + B) mod M = ((A mod M) + (B mod M)) mod M

<곱셈>
(A * B) mod M = ((A mod M) * (B mod M)) mod M

<뺄셈>
(A-B) mod M = ((A mod M) - (B mod M) + M) mod M
```
나누기의 경우에는 성립하지 않는다. 
Modular Inverse를 구해야 한다.
=나누기 연산에 대한 곱셈 연산 (출제빈도 낮음)

뺼셈의 경우에는 먼저 mod 연산을 한 결과가 음수가 나올 수 있기 때문에 위와 같은 연산을 적용한다.


## 뺄셈
뺄셈에 덧셈/곱셈과 같은 연산을 적용하면,

(6 - 5) % 3
(6%3 - 5%3) % 3
(0 -2) % 3

으로 중간 결과값이 음수가 나올 수 있다.
음수가 될 경우 결과의 부호가 프로그래밍 언어마다 다르기 때문에 결과의 부호를 0이상의 범위로 한정 시켜줘야만 한다.

0 <= a%c < c
0 <= b%c <c
이기 때문에

(a%c - b%c) 의 결과는
-c < (a%c - b%c) < 2c 를 만족한다.

0 <  (a%c - b%c + c) < 3c
여기에 c 를 더한 (a%c - b%c + c) 는 0보다 큰 값을 갖기 때문에, 이 상태에서 다시 c로 나누어주면 원하는 값을 얻을 수 있다.

```
<뺄셈>
(A-B) mod M = ((A mod M) - (B mod M) + M) mod M
```

## 나눗셈
<!--stackedit_data:
eyJoaXN0b3J5IjpbMTU3OTIwNjYzMyw4NTc0OTQ5XX0=
-->